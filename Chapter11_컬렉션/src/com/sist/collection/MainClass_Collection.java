package com.sist.collection;
/*
 * 	1. String : 웹 => 문자열 제어
 * 	2. Integer / Double
 * 	3. Date / Calendar
 * 	------------------------------> 오라클의 데이터형(문자열, 날짜형, 숫자형)
 * 	4. 데이터를 모아서 관리 : 배열
 * 		배열 => 단점 (고정적) => 크기를 확장하기 어렵다 (메모리 누수현상 => 최적화의 문제)
 * 					|
 * 					가변형(수시로 변경이 가능) ==> 크기를 정하지 않는다 => 컬렉션
 * 	5. 컬렉션 : 데이터는 어떤형이든 등록이 가능 => 형변환 => 데이터형 한 개로 통일 (제네릭스)
 * 	   ---- 열거형 , Properties => 12장
 * 	   ---- 기존에는 if문을 사용해서 구분 ==> if대신 사용할 수 있는 프로그램 : 어노테이션
 *     ------------------------------------------------------------------스프링과 연관되어 있으므로 잘 따라오기!!, MyBatis(Mapper : 데이터베이스만 연결할 수 있는 프로그램)
 *     스프링부트 , JPA
 *     ----------------중간에 STS툴을 다운 받는데, 3.XXX까지는 스프링 프레임워크가 있었음. 4.xxx에는 프레임워크는 없고 스프링부트만 존재함.
 *     					외국쪽은 스프링부트쪽으로 가고 있다. 그래서 스프링부트 할 줄 아는 사람을 많이 뽑느다. 스프링부트 안에 프레임워크가 있음. 
 *  6. 578page
 *  	= 컬렉션 프레임워크
 *  		** 프레임워크 (표준화를 하는 방법) => 스프링 프레임워크(형식이 동일), Jquery 프레임워크, MyBatis프레임워크...
 *  		** 표준화 (스프링형식을 모방)
 *  		-------
 *  		** Collection : 데이터 그룹, 다수의 데이터 => 모아서 처리
 *  		** 개발자가 누구든 상관없이 같은 메소드를 이용해야 된다
 *  	= 종류
 *  						Collection : 클래스가 아니라 인터페이스로 되어있음. 왜? 얘로부터 파생되는 클래스가 많아서. 우리는 구현된 클래스를 사용
 *  							|
 *  							|상속
 *  			-------------------------------------
 *  			|				|					|
 *  			List			Set					Map ==> 인터페이스 ==> 메소드가 거의 동일
 *  			|				|					|
 *  			|				-----------------	----------------------------
 *  			|				|				|			|					|
 *  			|				HashSet			TreeSet		HashTable			HashMap
 *  			|
 *  -------------------------
 *	|			|			| => 인터페이스를 구현한 클래스(주로 사용)
 *	ArrayList	Vector		Queue
 *							|
 *							LinkedList
 *	**List
 *	  1) 순서를 갖고 있다 (인덱스 번호 이용) ==> 배열형식
 *	  2) 저장된 데이터가 중복이 가능
 *	  3) 비동기화 (데이터베이스에 어느 것이 먼저 들어가는 지 모름) => 데이터베이스 프로그램에서 주로 사용(우리에게는 핵심*****)
 *	  4) CRUD ==> 데이터 처리(추가, 수정, 삭제, 검색)
 *		=> INSERT, UPDATE, DELETE, SELECT(데이터 조작)
 *	  5) 주요 메소드
 *		= add() => 데이터 추가
 *		= remove() => 데이터 삭제
 *		= set() => 데이터 수정
 *		= get() => 데이터 읽기
 *		= size() => 저장된 갯수
 *		= clear() => 전체를 삭제
 *		= isEmpty() => 존재여부
 *		-------------------------------> 모든 데이터는 오라클에 저장 ===> 메모리 저장했다가 브라우저에 전송(즉, 읽어와서 저장하고 브라우저에 전송)     
 *	**Set
 *	1) 순서가 없다(인덱스번호가 없다) => forEach사용해서 출력
 *	2) 데이터 중복을 허용하지 않는다(예) 장르, 음식의 종류) => 분야별 분류할때 많이 사용
 *	3) List에서 중복이 없는 데이터를 추출
 *	4) HashSet을 가장 많이 이용
 *	5) 주요 메소드
 * 		= add() => 데이터 추가
 *		= remove() => 데이터 삭제
 *		= set() => 데이터 수정
 *		= get() => 데이터 읽기
 *		= size() => 저장된 갯수
 *		= clear() => 전체를 삭제
 *		= isEmpty() => 존재여부
 *		-------------------------------> 메소드가 동일하다. 왜? 이 메소드는 Collection이 가지고 있어서 아래에 있는 클래스들도 메소드를 다 가지고 있다. 
 *	**Map(웹에서 지원하는 모든 클래스 Map형식을 가지고 있다)
 *		  ------------------- 
 *			HttpServletRequest(사용자가 보내주는 데이터를 가지고 있다), 
 *			HttpServletResponse(요청 처리 결과를 브라우저로 전송),
 *			HttpSession(서버에 데이터를 저장),
 *			Cookie(사용자의 브라우저에 저장)
 *		1) 키와 값으로 쌍으로 저장
 *			id, admin
 *		2) 키는 중복이 불가, 값만 중복 가능
 *		3) 클래스관리, 요청값 관리, 전송값 관리
 *		   ------- 스프링, 마이바티스 ==> id, 실제값이 항상 필요(중복이 아닌 id로 실제값을 찾아옴)
 *		4) 주로 사용하는 클래스는 HashMap (동일==>파일(properties))
 *	1. ArrayList(584page)
 *	---------------------	주로 	(데이터 중복을 허용 => 데이터베이스와 연동) ******* 핵심
 *	특징) MyBtis/JPA/JDBC (오라클관련) 
 *		1) 1차 프로젝트 : 목적 => 데이터베이스 연결 (최대한으로 오라클 연결) => SQL 
 *								JDBC/Jquery(Ajax)
 *		2) 2차 프로젝트 : 목적 => 스프링 => 스프링 라이브러리
 *								MyBatis / VueJS
 *		3) 3차 프로젝트 : 목적 => 우대사항(신기술)
 *								JPA / ReactJS
 *		**모방 => 전체 구현
 *		  데이터가 없다(데이터만 크롤링)
 *	---------------------------------------------------------------------------------
 *	ArrayList 저장 ==> Object
 *	add() ==> 오버로딩
 *	add(데이터)
 *	add(인덱스번호, 데이터) => 권장사항X. 속도 저하로 가급적이면 쓰지X
 *	예) H를 집어넣고 싶음.
 *	0	A
 *	1	B
 *	2	C
 *	==> 3 H 집어넣으면 인덱스번호가 3->4, 4->5...로 바뀜
 *			삭제하면 또 인덱스번호가 4->3, 5->4...로 땡겨옴 => 속도가 느려짐.
 *	3	D
 *	4	E
 *	5	F
 *	6	G
 *	==> add는 그냥 7 H로 집어넣음. 
 *	------------------------------- 인덱스번호는 순자척으로 생성(인덱스를 이용할때) , 삭제
 *	------------------------------------------------------------------------- LinkedList
 *	=> 데이터를 가지고 올때 형변환 ==> 같은 데이터형을 저장 ==> 클래스를 만들어서 사용
 *
 *	add(1) ===0 => 값을 가져올 때 object로 가져옴 ==>(int)로 형변환 필요
 *	add('A')==1	==>(char)
 *	add('b')==2 ==>(char)
 *	add("홍길동")==3 ==>(String)
 *	add(10.5)==4 ==>(double)
 *	add(true)==5 ==>(boolean)
 *	add(false)==6  ==>(boolean)
 *	----------------------> for문을 돌리기 어려움. 1번이면 int로, 2번이면 char로 지정해줘야함. 
 *	 
 *	CHAR(100) 고정
 *	==> 'a'	===> 어떤 글자가 들어오든 메모리 크기가 100임. 'a'다음에 99개는 null값으로 저장
 *	VARCHAR(100) 가변
 *	==> 'a' ==> 들어온 개수만큼 메모리 할당 . 한글자라 1byte할당함. 
 *
 * 플로그램은 가변이 좋다. 
 *
 */
import java.util.*;
public class MainClass_Collection {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ArrayList list = new ArrayList(); //지정하지 않는다(크기) ==> 가변형(18만개)
		//ArrayList<String> list = new ArrayList<String>();
		//ArrayList<E> -> E에 저장되는 데이터 형태를 써라. 제네릭스???
		// 저장
		// list.쳐서 리턴형이 대부분 Object
		list.add("홍길동"); // 인덱스 0번
		list.add("심청이"); // 1
		list.add("이순신"); // 2 -> 3
		list.add("강감찬"); // 3 -> 4
		//--------------------------순차적으로 추가
		list.add(2,"을지문덕"); // 2 ===> for
		//--------------------------인덱스로 추가
		System.out.println("=========== 컬렉션에 추가 add()============");
		System.out.println("저장된 인원수:"+list.size());		
		// 출력 size() ==> 저장된 갯수 ==> 배열(length)
		for(int i=0;i<list.size();i++)
		{
			//String name = list.get(i); //데이터 읽기 // 오류남
			// Object를 string으로 넘겨줘서 오류남. 1. 형변환? 2. Object로 받는다
			String name = (String)list.get(i);
			//String name = list.get(i).toString(); 문자열로 변환
			//				---------- Object
			System.out.println(i+"=>"+name);
		}
		System.out.println("========= 컬렉션 수정 set()=============");
		// 인덱스 2번 수정 ==> set(2, "수정데이터")
		list.set(2,"박문수"); // 을지문덕 ==> 박문수
		for(int i=0;i<list.size();i++)
		{
			String name = list.get(i).toString();
			System.out.println(i+"=>"+name);
		}
		System.out.println("======== 컬렉션 삭제 remove() ===========");
		// remove(int index)
		// 3번 삭제 => 퇴사해서 삭제해야함
		list.remove(3);
		System.out.println("저장된 인원수:"+list.size());
		for(int i=0;i<list.size();i++)
		{
			String name = (String)list.get(i);
			System.out.println(i+"=>"+name);
		}
		System.out.println("====== 전체 삭제 clear() ========");
		list.clear();
		System.out.println("저장된 인원수:"+list.size());
		if(list.isEmpty())//데이터가 없는지 확인
		{
			System.out.println("저장된 데이터가 없습니다!!");
		}
		/*
		 * 1. add(Object o) ==> Object(데이터형은 모든것을 사용할 수 있다) ==> 클래스형을 저장
		 * 2. set(int index, Object o)
		 * 3. remove(int index)
		 * 4. int size()
		 * 5. boolean isEmpty()
		 * 6. get(int index) : 리턴형이 Object
		 */
	}

}






