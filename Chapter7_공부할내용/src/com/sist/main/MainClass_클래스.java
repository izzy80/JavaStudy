package com.sist.main;
/*
 *  오라클, HTML/CSS, JavaScript, JSP, MVC, Spring, AWS => 자바 끝나고 배우는 것
 *  추가) JQuery(AJAX), VueJS(vuex, vue3), MyBatis
 *  				   ------
 *  추추가) Spring-Boot, ReactJS, Redux, JPA, MY-SQL
 *  				   -------
 *  ---------------------------------------------------------------------------------------
 *  오라클 시작하면 자바 공부할 시간 따로 없으니, 
 *  변수(데이터형), 연산자, 제어문, 배열(2~5장) => 스스로 공부하자~~~☆
 *  ---------------------------------------------------------------------------------------
 * 1) 클래스
 * 		= 클래스 정의하는 방법(객체지향 프로그램 => 클래스와 클래스의 연관 관계)
 * 			*** 접근지정어(공부 많이 해라!!)
 * 			= 클래스 : (다른 클래스와 연결해야 해서)public => 메모리 할당용
 * 			= 메소드 : 다른 클래스와 통신을 담담 (기능) ===> public 
 * 			= 변수 : 데이터 보호 ==> private
 * 			= 생성자 : 메모리 할당 => public
 * 				=> 클래스 만들려면 대상 분석(요구사항 분석) 필요 => 변수와 메소드를 파악
 * 			class ClassName
 * 			{
 * 				------------------------------------------------------------------------
 * 					속성, 필드 ==> 멤버변수(캡슐화 중심으로 보기) ==> getter/setter (변수 : 읽기/쓰기) = 인스턴스 변수 				
 * 					** 공유하는 변수(static)
 * 					** 변수는 기본형만 있는 것이 아니다. (배열, 클래스)
 * 				------------------------------------------------------------------------
 *  				생성자 : 오버로딩(어러개 있을 수 있다) => 변수에 대한 초기화 담당
 *  						생성자가 없는 경우 => 자동으로 추가(디폴트 생성자 => 매개변수 없는 생성자)
 * 				------------------------------------------------------------------------
 *  				메소드 : 기능 처리(속성, 필드)를 제어한다
 *  				위에 있는 속성, 필드와 관련이 없는 경우 (static 메소드)
 *  
 *  				String s = "Hello Java";
 *  				s가 가지고 있는 문자 갯수는? ==> s.length() => instance
 *  
 *  				ValueOf(10)
 *  				10을 문자열로 바꿔라 => 문자열과 관련이 없음 => static 
 *  				관련이 있냐 없냐에 따라 static 아니냐 이냐로 나눌 수 있다. 
 * 				-------------------------------------------------------------------------
 * 			}
 * 		= 객체 생성방법 (new)
 * 			클래스(사용자 데이터형) 저장 방법
 * 			기본형 ==> 메모리 자체에 값을 설정.
 * 				int a = 10;
 * 				----
 * 				10	a
 * 				-----
 * 				참조형 => 메모리에 실제로 저장된 데이터의 메모리 주소가 들어간다. ==> new의 역할
 * 				# 클래스라는 개념은 메모리에 데이터를 저장하는 것인데, 데이터가 여러개 일때 참조형은 데이터값이 메모리에 들어가지 못하고 주소값만 넘겨준다.
 * 				*** 클래스명 참조변수 = new 생성자()
 * 					  ------- 객체, 인스턴스
 * 				*** 클래스명 참조변수 = 클래스명.newInstance()
 * 				*** 클래스명 참조변수 = Class.forName().getInstance()
 * 				# 앞으로 new를 이용하지 않을 것이다. 			  			
 * 		= 메소드 정의하는 방법
 * 			[접근지정어][제어어] 리턴형 메소드명(매개변수...) -> <선언부>
 * 			{
 * 				<구현부>
 * 			}
 * 			public static : 객체마다 공통 사용되는 메소드 (데이터베이스 할때 많이 사용)
 * 			public final : 종단 메소드(오버라이딩이 불가능)
 * 			public abstract : 선언만 하는 메소드 ==> 구현 (프로그램에 맞게 구현해서 사용)
 * 			--------------- 추상 / 인터페이스(*****)
 * 		= 생성자 정의하는 방법 (291 Page)
 * 			= 특징
 * 				1) 클래스명과 동일
 * 				2) 리턴형이 없다(리턴형이 있는 경우 : 일반 인스턴스 메소드)
 * 				3) 변수의 초기화, 메모리에 저장시에 호출되는 메소드
 * 					-------- 시작 동시에 수행하는 기능이 있는 경우
 * 							------------- 웹, 윈도우(화면 UI가 존재)
 * 							= 자동 로그인, 쿠기, 윈도우 화면 디자인, 데이터베이스 연결, 서버 연결 ...
 * 							= 생성자를 많이 쓰는 이유는 프로그램이 구동될 때 첫번째로 호출되는 메소드이 이기 때문
 * 				4) 오버로딩을 지원
 * 					초기화 => 직접 초기화(매개변수X), 사용자로부터 받아서 초기화(매개변수O)
 * 					오버로딩은 사실 일반메소드에서 등장하지 않고, 생성자에서 많이 등장함. 
 * 					=> 메소드명이 동일
 * 					=> 매개변수가 다르다(갯수, 데이터형)
 * 					=> 리턴형은 관계가 없다. 						
 * 															 저장시
 * 					method() ==============================> method()
 * 					method(int a) =========================> method(int)
 * 					method(int b) =========================> method(int)
 * 					method(int a,b) =======================> method(int, int)
 * 					***** 같은 메소드명을 이용해서 다른 기능을 추가할 때 사용
 * 					# 매개변수명과는 상관이 없다. 
 * 		= this 키워드 : 객체 자신을 키워드로 나타냄
 * 		  ---------- this는 모든 클래스에 사용
 * 					----- 생성자, 인스턴스 메소드 안에서만 사용 (static 메소드에서는 this가 존재하지 않는다)
 * 					class A
 * 					{
 * 						public A(){}
 * 						public void display(){}
 * 						public static void aaa(){}
 * 					} 
 * 					
 * 					this의 특징 ==> static Object this;
 * 					this 생성시점은 객체가 생성시에 저장이 된다. ==> 생성된 객체의 주소값을 갖고 있음
 * 					A a = new A();
 * 					=> 컴파일러 (this = a) 
 * 					# 컴파일러가 this에 a를 저장해줌. 자동처리가 되어서 우리랑 관련이 없지만 알고는 있어라. 
 * 					A b = new A();
 * 					=> 컴파일러 (this = b)
 * 					this는 자신의 객체를 전송, 지역변수와 구분
 * 					------------------- 윈도우
 * 2) 상속 ==> 객체지향의 특성 (데이터보호는 방법, 재사용, 수정, 추가, 공통적인 내용을 모아서 모듈화)
 * 						 -------------  ----  --------  -------------------
 * 							캡슐화		상속/포함	오버라이딩/오버로딩(다형성)	추상화 => 4대 특성
 * 							** 추상 => 공통적으로 사용하는 ==> 문법이 아니라 권장
 * 							class A
 * 							{	
 * 								글쓰기()
 * 								상세보기()
 * 								목록출력()
 * 								수정()
 * 								삭제()
 * 								검색()
 * 							}
 * 		
 * 							class B
 * 							{
 * 								글쓰기()
 * 								상세보기()
 * 								목록출력()
 * 								수정()
 * 								삭제()
 * 								검색()
 * 								------------> 같은 코드인데 없앨수 있는 방법이 없을까??
 * 								답변()		  상속을 이용해서 class C처럼 만들거나 class D의 방법도 있다.  
 * 							}
 * 							
 * 							class C extends A
 * 							{
 * 								// 앞에 글쓰기()~검색()까지의 기능을 이미 담고 있음
 * 								답변()
 * 							}
 * 		
 * 							class D
 * 							{
 * 								A a = new A(); // 클래스 안에 클래스 객체를 집어넣고 시작할 수도 있다. 
 * 								// 단, 단점은 변경이 어렵다. 가져오면 그대로 써야한다. 
 * 								답변()
 * 							}
 * 					
 * 							재사용(기능을 변경) / 포함 (기능 변경이 없는 경우)
 * 							--------------	----------------------
 * 							사용자 정의 클래스	 라이브러리 
 * 		= 자바 상속의 특징(310 page)
 * 			= 재사용이 가능
 * 			= 반복 코딩을 제거
 * 			= 기존의 클래스를 확장해서 새로운 클래스 제작 => 개발자가 수정해서 사용이 가능(오버라이딩)
 * 			= 유지보수
 * 			= 상속은 extends(확장)를 사용
 * 			= 단일 상속만 가능하다
 * 			= 상속 내리는 클래스 > 상속 받는 클래스 ==> 상속이 있는 경우에만 클래스의 크기 비교가 가능하다(형변환 많이 공부하기!!!!!!)
 * 				class Super
 * 				class Sub extends Super
 * 				==> 메모리 할당 (Sub 사용)
 * 						Super
 * 							int a
 * 							int b
 * 							aaa()
 * 							bbb()
 * 
 * 						Sub extends Super
 * 							------------
 * 							int a 
 * 							int b
 * 							aaa()
 * 							bbb() -> 코딩되어 있지 않지만 상속으로 포함되어 있음. 
 * 							------------
 * 							int c;
 * 							ccc()
 * 					1) 상위 클래스로 생성 (추상 클래스, 인터페이스 => 자신이 메모리 할당이 안된다) # 자신이 메모리할당을 못하기 때문에 구현된 클래스를 받아서 사용한다
 * 						Super s = new Sub(); => 메소드의 주소값(오버라이딩)
 * 						-----	  ----------
 * 						변수			메소드  => 앞에서 변수가지고 오고 뒤에서 메소드가지고 오는 자리
 * 							  - 사용이 가능
 * 								s.a, s.b, s.aaa(), s.bbb() => Super가 갖고 있는 것. 그래서 대체로 Sub를 이용해서 객체를 생성함. (상속을 했는데 Super만 사용할리가 없잖슴.) 
 * 								--------  ----------------
 * 								Super		Sub
 * 					2) 하위 클래스로 생성
 * 						Sub s = new Sub(); => *****기본 코드(가장 많이 사용)
 * 							Sub가 가지고 있는 변수/메소드
 * 
 * 					3) 상위 클래스로 생성 받는 하위클래스로 받는다
 * 						Sub s = (Sub)new Super()
 * 							Sub가 가지고 있는 변수/메소드
 * 
 * 		= super 키워드 : 상위클래스를 제어(변수값 변경, 메소드 호출시에 주로 사용)  
 * 			# 가끔 한 번씩 등장함
 * 		= 메소드 오버라이딩 => 추상 클래스 / 인터페이스
 * 							--------------- # 선언만 하기 때문에 상속으로 받아서 처리해야함
 * 			1) 메소드명 동일
 * 			2) 매개변수 동일
 * 			3) 리턴형 동일
 * 			4) 접근 지정어는 확대가 가능(public)
 * 			# 오버라이딩은 덮어쓰기. 그래서 매개변수도 동일해함. 
 * 		= final 키워드
 * 			1) 반드시 초기화를 한다
 * 			2) 지역변수에서도 사용이 가능(유일)
 * 			3) 변수는 대문자로 사용한다
 * 			4) 변경할 수 없다 
 * 			final => 상수형 변수
 * 			static final : 상수
 * 			# 특별한 경우가 아니면 자주 등장하지는 않는다
 * 		= Object 클래스 : 모든 클래스의 상위 클래스
 * 						-------- 라이브러리, 사용자 정의 클래스
 * 			
 * 3) 인터페이스 / 추상클래스 (Front-End)
 * 		= 인터페이스 / 추상클래스의 차이점 ==> 95%
 * 			목적)
 * 				추상 클래스는 상속받아서 확장하는 목적
 * 				인터페이스는 관련된 여러개의 클래스를 묶어서 관리(메소드가 동일)
 * 				=> 공통점
 * 					= 자신이 메모리 할당을 할 수 없다. (항상 상속을 통해서 구현한 다음에 사용해야 한다) 
 * 					  ----------------------- 하위클래스를 이용해서 처리
 * 				------------------------------------------------------
 * 							추상 클래스						인터페이스
 * 				------------------------------------------------------
 * 				상속			단일 상속						다중 상속
 * 				------------------------------------------------------
 *   			메소드		구현된 메소드					구현이 안 된 메소드
 *   						구현이 안 된 메소드				구현된 메소드(JDK1.8이상에 추가된 기능)
 *   													default
 * 				------------------------------------------------------
 * 				변수			인스턴스 변수가 존재				인스턴스변수가 없다
 * 														상수형 변수만 설정이 가능
 * 				------------------------------------------------------
 * 				생성자		존재							존재하지 않는다
 * 				------------------------------------------------------
 * 				상속시 키워드	extends						implements
 * 				------------------------------------------------------
 * 				접근지정어		전체사용						public만 가능
 * 				------------------------------------------------------
 * 		= 인터페이스 / 추상클래스 정의
 * 			추상클래스
 * 			public abstract class ClassName
 * 			{
 * 				----------------------------
 * 				변수 설정 (인스턴스, static)
 * 				----------------------------
 * 				생성자
 * 				----------------------------
 * 				구현된 메소드
 * 				----------------------------
 * 				구현이 안 된 메소드(추상메소드) : 공통으로 사용되는 기능
 * 				예) 마우스
 * 					=> 마우스 클릭
 * 					=> 마우스 이동
 * 					=> 마우스 드래그
 * 					=> 마우스 올리기
 * 					=> 마우스 내리기
 * 
 * 					버튼
 * 					=> 클릭, 더블 클릭
 * 					=> 프로그램마다 사용 방법이 다르다 (구현이 안 된 상태로 선언)
 * 						로그인 / 취소, 계산기 (1,2,3...)
 * 					public abstract 리턴형 메소드명(매개변수...);
 * 				--------------------------------
 * 			}
 * 
 * 			인터페이스 : 추상 클래스의 일종 ==> 추상 클래스의 단점을 보완(실제 프로그램에서 인터페이스가 더 많이 사용)
 * 			public interface interface명
 * 			{
 * 				---------------------------------
 * 				상수
 * 					int a = 10;
 * 					----------------> 상수는 반드시 값을 지정 #일반 클래스는 없어도 상관없는데 인터페이스는 아님
 * 					자동 추가되는 부분
 * 					(public static final) int a = 10;
 * 				---------------------------------
 * 				구현이 안 된 메소드
 * 					void display();
 * 					자동 추가되는 부분
 * 					(public abstract) void display();
 * 				---------------------------------
 * 				구현이 된 메소드
 * 					default void aaa(){}
 * 					-------  반드시 추가(자동추가X)
 * 					
 * 					자동 추가되는 부분
 * 					(public) default void aaa(){}
 * 				---------------------------------
 * 			}
 * 		= 인터페이스 / 추상클래스 구현방법
 * 			abstract class A
 * 				=> aaa(), bbb(), abstract ccc()
 * 					# 1-1) ccc()만 구현이 안 됨
 * 			=> class B extends A
 * 				{
 * 					// 반드시 구현해야 되는 부분
 * 					추상메소드(구현이 안 된 메소드) => 반드시 구현해서 사용
 * 					ccc(){} -> 1-2)구현해야함.
 * 					ddd(){} // 2-1) 추가 
 * 				}
 * 				// 메모리 할당하는 방법
 * 				B b =  new B() ==> aaa(), bbb(), ccc(), ddd()
 * 				
 * 				2-2) A로 생성하게 되면 B에 있는 것을 다 사용하지 못할 수도 있음 
 * 				A a = new B() ==> aaa(), bbb(), ccc() => ddd()는 사용 불가
 * 				------------- 오버라이딩된 메소드를 호출한다 
 * 				
 * 				abstract class A
 * 				{
 * 					aaa(){1}
 * 					bbb(){2}
 * 					abstract ccc()
 * 				} 
 * 				class B extends A
 * 				{
 * 					aaa(){10}
 * 					bbb(){20}
 * 					ccc(){30}
 * 					ddd(){40}
 * 				}
 * 				1)
 * 				B b = new B();
 * 				b.aaa() ==> 10
 * 				b.bbb() ==> 20
 * 				b.ccc() ==> 30
 * 				b.ddd() ==> 40
 * 				2)
 * 				A a = new B();  # 생성자의 역할은 앞에 a.aaa()의 주소를 B.aaa()로 바꿈. 
 * 				---	  -------- 메소드의 주소를 B로 수행
 * 				a.aaa() => b.aaa() ==> 10
 * 				a.bbb() => b.bbb() ==> 20
 * 				a.ccc() => b.ccc() ==> 30
 * 				3) 
 * 				A c = new A(); => 오류(메모리 할당이 불가능) => 미완성된 클래스
 * 				추상 클래스는 반듯 상속을 받아서 구현후에 사용한다. => 오버라이딩 기법
 * 		
 * 		interface A
 * 		class B implements A
 * 		{
 * 			선언된 메소드 구현해서 사용
 * 		}
 * 		=> 인터페이스도 상위 클래스와 동일하게 취급
 * 		A a = new B()
 * 		---- 인터페이스로 받아서 처리 => 여러개를 묶어서 관리 목적
 * 		= 인터페이스 상속
 * 			interface ==========> interface
 * 						extends
 * 			interface ==========> class
 * 						implements
 * 			다중 상속 가능
 * 			interface A
 * 			interface B extends A
 * 			interface C	extends B -> 단일 상속(이렇게 코딩 X)
 * 			=============
 * 			interface A
 * 			interface B
 * 			interface C extends A,B -> 다중 상속(이렇게 코딩O)
 * 
 * 			interface A
 * 			interface B
 * 			class C implements A,B
 * 
 * 			interface A
 * 			interface B
 * 			class C 
 * 			class D extends C implements A,B -> extends로 받고, implements로 받음
 * 	
 * 		= 1.8 => 인터페이스 default 메소드 : 구현이 된 메소드
 * 				default 리턴형 메소드명(매개변수...) # default가 있으면 구현된 메소드
 * 				{
 * 					구현
 * 				}
 * 				----------------------------- 추상클래스가 사라진다. 
 * 				 라이브러리 아직 사용중인 추상 클래스가 존재
 * 				-------------------------------- 추상 클래스가 나오는 순간 여러개 기능이 있다고 생각하기
 * 				Connection(interface임) : Oracle, MYSQL, MS=SQL, MariaDB .... #하나의 인터페이스를 갖고 여러개를 제어한다. 
 * 				DocumentBuildFactory ==> HTML, XML, WML, HDML, VML...
 * 				Mouse
 * 
 * 4) 예외처리(오늘 배울 내용)
 * 		= 예외처리 종류 (예외 복구, 예외 회피)
 * 		= 자바에서 제공하는 예외 처리 클래스 (계층구조)
 * 		= 실행 순서
 * 		= 사용자정의 예외처리 ==> 호출 방법
 * ----------------------------------------------- 자바 문법 사항
 *  라이브러리 
 *  -------Object, String, StringBuffer, Math, Wrapper ==> java.lang
 * 		   StringTokenizer, Date , Calendar, SimpleDateFormat
 * 	    |- List , Set, Map ===> java.util		
 * 예외  |  IO
 * 처리	|  ----------------------------------------------------------- 웹
 * 필요	|-  SQL => java.sql *****
 * 		  ----------------------------------------------------------- 웹 관련 라이브러리별도 다운로드
 */
public class MainClass_클래스 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
