 /* 
  * 들어가기전에
  * 변수(데이터형)
 * int, double, boolean,String 
 * 연산자 : 증감연산자, 형변환, 산술, 비교, 논리, 대입, 삼항
 * 제어문 ㅣ if, for, while, break
 * ---------------------------------------------
 * 배열 1차원 : String[]
 * ----------------------------------------------
 * 클래스 : 멤버변수, 생성자, 메소드
 * 		=> 캡슐화, 오버라이딩, 포함 클래스 
 * 인터페이스
 * 예외처리(throws, try-catch)
 * ----------------------------------------------라이브러리
 * String / StringBuffer/Wrapper/Date/Calendar/List(배열) / Map / Set / IO
 * ------------------------------------------------------------------------
 * SQL(데이터베이스 연동)
 * 
 * 
 * 브라우저에서 실행할 수 있는 언어가 HTML/CSS, JavaScipt만 실행됨.
 * 오라클 안에 데이터를 영구적으로 저장한다. 
 * 자바를 공부한 이유는 브라우저(컴퓨터)랑 오라클을 연결하는 것이 좋은데 이것이 안 된다. 이 기능이 없다. 할 수 있는 방법은 연결하는 방법을 찾는 것. 
 * 중간에 받아서 오라클로 넘겨서 데이터를 받아서 다시 브라우저에 보내주는 이 역할을 수행하는 것이 자바이다.  
 * 데이터를 가져와서 브라우저에 뿌리는. 이 프로그램을 짤 줄 알아야함. 
 * 
 * html보다 속도가 빨라서 react-vue를 최근에 많이 사용함. 
 * 웅답받은 것을 화면으로 출력만 해주는 역할 html
 * 응답하고 요청을 받기 위해서 java를 배움
 * 화면 출력 -> front
 * 응답 및 요청 => back
 */
package com.sist.exception;
/*
 *  컴파일(이진파일변경), 			인터프리터(한줄씩 읽기서 출력)
 *  --------------				---------------------
 *  	javac								java
 *  	  |					  				|
 *  	프로그래머							사용자의 오류
 *  --------------				----------------------
 *  CheckExecption					UnCheckException
 *  컴파일러가 예외처리가 되었는지 여부를 확인 	확인하지 않는다 => 예외처리 생략이 가능
 *  
 *  CheckException
 *  	= IOException : 파일명, 경로명
 *  	= ClassNotFoundException : 클래스가 없는 경우 (리플렉션 = new 없이 메모리 할당)
 *  	= SQLException : 데이터베이스 연결(오라클, MySQL)
 *  	= InterruptedException : 쓰레드 충돌 
 *  		# 메모장, 그림판(=>스레드) 동시에 사용가능하게 만듦. 충돌되면 윈도우 자체가 깨져버림. 
 *  	= MalformedURLException : IP, URL주소가 틀린경우 ==> 크롤링하면 많이 등장
 *  
 *  UnCheckException
 *  	= ArrayIndexOutOfBoundsException : 배열범위가 초과시에 (인덱스번호 오류)
 *  								=> 12장(컬렉션)
 *  	= NumberFormatException : 정수변환 ==> 웹 / 윈도우는 정수를 전송할 수 없다(내가 10을 보내도 문자열로 들어감)
 *  	= NullPointerException : 객체 생성없이 선언후 사용
 *  		모든 클래스는 기본값이 null => 메소드나 변수 사용이 안 됨
 *  	= ClassCastException : 클래스 형변환 ==> 제네릭스 (자동 형변환)
 *  		class A<T> ==> T는 임시클래스라서 디폴트가 Object ==> 12장 (데이터베이스의 기본)
 *  		{
 *  			T t;
 *  			public void setT(T t)
 *  			{
 *  			}
 *  			public T getT()
 *  			{
 *  			}
 *  		}
 *  		
 *  		----------------------------------------------------------------------
 *  		1) 처리방법
 *  			***1. 예외복구(직접처리) try~catch~finally => 프로그래머가 처리
 *  			***2. 예외회피(간접처리) throws ==> 시스템에 알려준다(예외 떠넘기기)
 *  					라이브러리에 많이 존재
 *  					sleep() throws InterruptedException
 *  			3. 예외던지기(임의로 발생) : throw ==> 사용빈도는 거의 없다(continue)
 *  				----------------- 사용자 정의 예외처리
 *  		2) 사용법
 *  			try : 정상 수행이 가능한 코딩(예외가 발생이 가능성) ==> 에러에 대비한 코딩
 *  				=> 프로그래머 실수
 *  				=> 사용자 입력 오류
 *  			catch : 오류 발생시에 어떻게 처리할 지 코딩(복구 => 에러확인)
 *  					=> 프로그래머 실수(복구) => 소스 수정
 *  					=> 사용자 실수 => 다시 입력을 요청
 *  					=> 예상되는 에러만큼 catch를 사용할 수 있다(멀티) => 통합해서 이용 가능
 *  					=> 전체예외처리가 가능한 클래스 : Exception / Throwable
 *  			finally : 무조건 수행
 *  						try에서 수행 ===> 정상 수행
 *  						catch에서 수행 ===> 중간에 오류가 발생함
 *  						try/catch수행 상관없이 무조건 수행 (파일 닫기, 서버연결 해체, 데이터베이스 닫기)
 *  			---------------------> 생략이 가능(필요시에만 사용)
 *  			
 *  			예)
 *  				사이트 => 오류(다음화면이 없다), 로딩 시간 오래 걸린다 ==> 사이트 이동
 *  				String num = "10";
 *  				=> 정수 변환
 *  				int i = Integer.parseInt(num); ==> 오류발생(오류에 대한 대비가 없는 경우) => 프로그램이 종료
 *  				화면 출력 
 *  	코딩퇸 것	->	1---
 *  				2---
 *  				3---
 *  				4---
 *  				5---	
 * 					---------------------정상수행(5번까지 수행)
 *  
 *  				에러발생에 대한 대비
 *  				--------------
 *  				try
 *  				{
 *  					문장 1 => 정상수행
 *  					문장 2 => 정상수행
 *  					문장 3 => 정상수행 ==> try가 종료한 다음에 catch는 수행하지 않고 다음 문장으로 넘어감
 *  				}catch(A)
 *  				{
 *  					처리문장 4
 *  				}
 *  				catch(B)
 *  				{
 *  					처리문장 5
 *  				}
 *     				catch(C)
 *  				{
 *  					처리문장 6
 *  				}
 *  				문장 7
 *  				---------------------------------------------
 *     				try
 *  				{
 *  					문장 1 => 정상수행
 *  					문장 2 => 오류발생 (B) ==> B라는 오류를 찾는다
 *  					문장 3 => 정상수행 
 *  					   |
 *  				}catch(A) ==> 다중 조건문(선택문)
 *  				{
 *  					처리문장 4
 *  				}	  |
 *  				catch(B)
 *  				{
 *  					처리문장 5 ==> 수행
 *  				}	  |
 *     				catch(C)
 *  				{
 *  					처리문장 6
 *  				}
 *  				문장 7
 *  				// 순서가 있게 코딩하는 것은 중요하다
 *  				----------------------------------------------------
 *  				try
 *  				{
 *  					문장 1 => 정상수행
 *  					문장 2 => 오류발생 (B) ==> B라는 오류를 찾는다
 *  					문장 3 => 정상수행 
 *  					   |
 *  				}catch(A|B|C) ==> 다중 조건문(선택문)
 *  				{
 *  					처리문장 4
 *  				}	  
 *  				문장 7
 *  				------------------------------------------------------
 *    				try
 *  				{
 *  					문장 1 => 정상수행
 *  					문장 2 => 오류발생 (B) ==> B라는 오류를 찾는다
 *  					문장 3 => 정상수행 
 *  					   |
 *  				}catch(Exception) ==> 다중 조건문(선택문) Exception : 모든 예외처리가 가능
 *  				{			
 *  					처리문장 4
 *  				}	  
 *  				문장 7
 *  				
 */
import java.util.Scanner;
public class 예외처리_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//Thread.sleep(100);
		
		//UnCheckException => 예외처리 생략이 가능 => 정수변환, 배열, 나누기, Null
		try 
		{
			Scanner scan = new Scanner(System.in);
			System.out.print("정수 두 개 입력(10 10):"); // 한칸 스페이스바 하면 두개를 받을 수 있음
			int[] arr = new int[2];
			arr[0] = scan.nextInt();
			arr[2] = scan.nextInt(); // 인덱스 번호 초과로 인한 오류발생 ==> catch
			// 오류발생 ==> try-catch없으면 프로그램이 비정상적으로 종료됨
			
			int res = arr[0]/arr[1];
			System.out.println("res="+res);
			System.out.println("프로그램 종료");	
		}catch(ArrayIndexOutOfBoundsException ex)
		{
			// 에러 확인
			//System.out.println(ex.getMessage()); //처리
			ex.printStackTrace(); // 실행과정을 출력 ==> 422page
			// at com.sist.exception.예외처리_1.main(예외처리_1.java:186) 결과창에 뜸
			// 파란색 글자 예외처리_1.java:186 클릭하면 오류난 위치로 이동함
		}
		System.out.println("프로그램 종료");
	}

}
